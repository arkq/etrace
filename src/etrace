#!/usr/bin/env python3
# $Revision: 3.0 $

import os
import re
import subprocess
import sys


TRACE_FIFO_NAME = "TRACE"
TRACE_FIFO_CREATED = False


def trace_init():
    """Create a TRACE FIFO if it doesn't exist."""
    global TRACE_FIFO_CREATED
    try:
        os.mkfifo(TRACE_FIFO_NAME)
        TRACE_FIFO_CREATED = True
    except FileExistsError:
        pass


def trace_end():
    """Remove TRACE FIFO if it exists."""
    if TRACE_FIFO_CREATED:
        os.remove(TRACE_FIFO_NAME)
    sys.exit(0)


def load_symbols(prog: str, cppfilt: bool = True) -> dict:
    """Load symbols from a program's symbol table using nm tool."""
    sym = {}

    pattern = re.compile(r"[^:]+:\s*([0-9a-fA-F]+)? (\w) (\w+)")
    sp = subprocess.run(["nm", "-o", prog], stdout=subprocess.PIPE, text=True)
    for line in sp.stdout.split("\n"):
        match = pattern.match(line)
        if not match or match.groups()[0] is None:
            continue
        addr, _, name = match.groups()
        addr = int(addr, 16)
        sym[addr] = name

    if "__cyg_profile_func_enter" not in sym.values():
        print(f"Error: {prog} doesn't appear to be instrumented")
        trace_end()

    if cppfilt:
        sp = subprocess.run(["c++filt"], input="\n".join(sym.values()),
                            capture_output=True, text=True)
        sym = dict(zip(sym.keys(), sp.stdout.split("\n")))

    return sym


def trace(prog):
    """Print a program's trace."""
    printer = Printer()
    sym = load_symbols(prog, cppfilt=True)
    subprocess.Popen([os.path.abspath(prog)])
    with open(TRACE_FIFO_NAME, 'r') as f:
        for line in f:
            tag, addr = line.split()
            if tag == "EXIT":
                break
            name = sym.get(int(addr, 16), "??")
            printer(tag, name)
    print()


class Printer:

    def __init__(self):
        self.level = 0
        self.name = None
        self.count = 0

    def __call__(self, tag, name):
        if tag == "enter":
            self.do_func(name)
            self.level = self.level + 1
            self.name = name
        else:
            self.level = self.level - 1

    def print_func(self, name):
        print("\n" + self.level * "| " + "\\- " + name, end='')

    def print_totals(self):
        print(f" (total: {self.count + 1} times)", end='')

    def do_func(self, name):
        if self.name == name:
            # was the counter counting?
            if self.count == 0:
                self.print_func(name)
            self.count = self.count + 1
        else:
            # New name received. Was the counter counting?
            if self.count > 0:
                self.print_totals()
                self.count = 0
            self.print_func(name)


if __name__ == "__main__":

    if len(sys.argv) != 2:
        print(f"Usage: {sys.argv[0]} <prog>")
        sys.exit(1)

    trace_init()
    trace(sys.argv[1])
    trace_end()
